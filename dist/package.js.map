{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["// @ts-ignore\nimport { version } from '../package.json';\n\ntype milliseconds = number;\n\nexport type QueueableFunction<O = {[k: string]: any}, R = void> = (options: O) => Promise<R>;\n\nexport type QueueableSyncFunction<O = {[k: string]: any}, R = void> = (options: O) => R;\n\nexport interface FunctionQueueResult<R = void> {\n  duration: milliseconds;\n  result?: R;\n  error?: any;\n};\n\nexport interface FunctionQueueOptions {\n  waitTimeBetweenRuns: milliseconds;\n  maxRetries: number;\n}\n\nconst defaultOptions: FunctionQueueOptions = {\n  waitTimeBetweenRuns: 100,\n  maxRetries: 1,\n};\n\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst syncSleep = (ms: number) => {\n    const end = Date.now() + ms;\n    while (Date.now() < end) continue;\n}\n\nexport class FunctionQueue<O = {[k: string]: any}, R = void> {\n  static version = version;\n\n  private _fn: QueueableFunction<O, R>;\n  private _queue: O[] = [];\n  private _options: FunctionQueueOptions;\n\n  constructor(\n    fn: QueueableFunction<O, R>,\n    options?: FunctionQueueOptions,\n  ) {\n    this._fn = fn;\n    this._options = {\n      ...defaultOptions,\n      ...(options || {}),\n    };\n  }\n\n  public queuePayload(payload: O) {\n    this._queue.push(payload);\n  }\n\n  private _tryFn = async (payload: O, retries: number = 0): Promise<R | any> => {\n    try {\n      await sleep(this._options.waitTimeBetweenRuns);\n\n      const result = await this._fn(payload);\n\n      return result;\n    } catch (error) {\n      if (retries < this._options.maxRetries) {\n        return await this._tryFn(payload, retries + 1);\n      }\n\n      throw error;\n    }\n  }\n\n  public async processQueue(): Promise<FunctionQueueResult<R>[]> {\n    const results: FunctionQueueResult<R>[] = [];\n\n    let startTime;\n    let endTime;\n\n    let payload: O;\n\n    while (payload = this._queue.shift() as O) {\n      startTime = Date.now();\n      try {\n        const result = await this._tryFn(payload);\n        endTime = Date.now();\n\n        results.push(\n          {\n            duration: endTime - startTime,\n            result,\n          }\n        );\n      } catch (error) {\n        endTime = Date.now();\n        results.push(\n          {\n            duration: endTime - startTime,\n            error,\n          }\n        );\n      }\n    }\n\n    return results;\n  }\n}\n\nexport class FunctionSyncQueue<O = {[k: string]: any}, R = void> {\n  static version = version;\n\n  private _fn: QueueableSyncFunction<O, R>;\n  private _queue: O[] = [];\n  private _options: FunctionQueueOptions;\n\n  constructor(\n    fn: QueueableSyncFunction<O, R>,\n    options?: FunctionQueueOptions,\n  ) {\n    this._fn = fn;\n    this._options = {\n      ...defaultOptions,\n      ...(options || {}),\n    };\n  }\n\n  public queuePayload(payload: O) {\n    this._queue.push(payload);\n  }\n\n  private _tryFn = (payload: O, retries: number = 0): R | any => {\n    try {\n      syncSleep(this._options.waitTimeBetweenRuns);\n\n      const result = this._fn(payload);\n\n      return result;\n    } catch (error) {\n      if (retries < this._options.maxRetries) {\n        return this._tryFn(payload, retries + 1);\n      }\n\n      return error;\n    }\n  }\n\n  public processQueue(): FunctionQueueResult<R>[] {\n    const results: FunctionQueueResult<R>[] = [];\n\n    let startTime;\n    let endTime;\n\n    let payload: O;\n\n    while (payload = this._queue.shift() as O) {\n      startTime = Date.now();\n      try {\n        const result = this._tryFn(payload);\n        endTime = Date.now();\n        results.push(\n          {\n            duration: endTime - startTime,\n            result,\n          }\n        );\n      } catch (error) {\n        endTime = Date.now();\n        results.push(\n          {\n            duration: endTime - startTime,\n            error,\n          }\n        );\n      }\n    }\n\n    return results;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAoBA,MAAM,iBAAuC;AAAA,IAC3C,qBAAqB;AAAA,IACrB,YAAY;AAAA;AAGd,MAAM,QAAQ,CAAC,OAAe,IAAI,QAAQ,aAAW,WAAW,SAAS;AAEzE,MAAM,YAAY,CAAC,OAAe;AAC9B,UAAM,MAAM,KAAK,QAAQ;AACzB,WAAO,KAAK,QAAQ;AAAK;AAAA;AAGtB,4BAAsD;AAAA,IAO3D,YACE,IACA,SACA;AANM,oBAAc;AAkBd,oBAAS,OAAO,SAAY,UAAkB,MAAwB;AAC5E,YAAI;AACF,gBAAM,MAAM,KAAK,SAAS;AAE1B,gBAAM,SAAS,MAAM,KAAK,IAAI;AAE9B,iBAAO;AAAA,iBACA,OAAP;AACA,cAAI,UAAU,KAAK,SAAS,YAAY;AACtC,mBAAO,MAAM,KAAK,OAAO,SAAS,UAAU;AAAA;AAG9C,gBAAM;AAAA;AAAA;AAvBR,WAAK,MAAM;AACX,WAAK,WAAW,kCACX,iBACC,WAAW;AAAA;AAAA,IAIZ,aAAa,SAAY;AAC9B,WAAK,OAAO,KAAK;AAAA;AAAA,UAmBN,eAAkD;AAC7D,YAAM,UAAoC;AAE1C,UAAI;AACJ,UAAI;AAEJ,UAAI;AAEJ,aAAO,UAAU,KAAK,OAAO,SAAc;AACzC,oBAAY,KAAK;AACjB,YAAI;AACF,gBAAM,SAAS,MAAM,KAAK,OAAO;AACjC,oBAAU,KAAK;AAEf,kBAAQ,KACN;AAAA,YACE,UAAU,UAAU;AAAA,YACpB;AAAA;AAAA,iBAGG,OAAP;AACA,oBAAU,KAAK;AACf,kBAAQ,KACN;AAAA,YACE,UAAU,UAAU;AAAA,YACpB;AAAA;AAAA;AAAA;AAMR,aAAO;AAAA;AAAA;AApEF,EADF,cACE,UAAU;AAwEZ,gCAA0D;AAAA,IAO/D,YACE,IACA,SACA;AANM,oBAAc;AAkBd,oBAAS,CAAC,SAAY,UAAkB,MAAe;AAC7D,YAAI;AACF,oBAAU,KAAK,SAAS;AAExB,gBAAM,SAAS,KAAK,IAAI;AAExB,iBAAO;AAAA,iBACA,OAAP;AACA,cAAI,UAAU,KAAK,SAAS,YAAY;AACtC,mBAAO,KAAK,OAAO,SAAS,UAAU;AAAA;AAGxC,iBAAO;AAAA;AAAA;AAvBT,WAAK,MAAM;AACX,WAAK,WAAW,kCACX,iBACC,WAAW;AAAA;AAAA,IAIZ,aAAa,SAAY;AAC9B,WAAK,OAAO,KAAK;AAAA;AAAA,IAmBZ,eAAyC;AAC9C,YAAM,UAAoC;AAE1C,UAAI;AACJ,UAAI;AAEJ,UAAI;AAEJ,aAAO,UAAU,KAAK,OAAO,SAAc;AACzC,oBAAY,KAAK;AACjB,YAAI;AACF,gBAAM,SAAS,KAAK,OAAO;AAC3B,oBAAU,KAAK;AACf,kBAAQ,KACN;AAAA,YACE,UAAU,UAAU;AAAA,YACpB;AAAA;AAAA,iBAGG,OAAP;AACA,oBAAU,KAAK;AACf,kBAAQ,KACN;AAAA,YACE,UAAU,UAAU;AAAA,YACpB;AAAA;AAAA;AAAA;AAMR,aAAO;AAAA;AAAA;AAnEF,EADF,kBACE,UAAU;",
  "names": []
}
